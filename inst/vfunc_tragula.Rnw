% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
\documentclass[article]{tragula}
\usepackage{amssymb}
\usepackage{wrapfig}
% Feel free to use other standard packages here if needed

\newcommand{\tragula}{\textsf{Tragula}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for tragula.cls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% just as usual
\author{Robin K. S. Hankin\orcid{https://orcid.org/0000-0001-5982-0415}\\
  University of Stirling}
%% the \author{} macro specifes a list of authors; use \And to
%% separate authors and \AND to indicate a new line. 

\title{Introducing the \pkg{vfunc} \proglang{R} package}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Robin K. S. Hankin}
\Plaintitle{Introducing the vfunc R package}
\Shorttitle{Introducing the \pkg{vfunc} \proglang{R} package}

%% an abstract and keywords

\Abstract{

In mathematics, given two functions
$f,g\colon\mathbb{R}\longrightarrow\mathbb{R}$, it is natural to
define $f+g$ as the function that maps $x\in\mathbb{R}$ to $f(x) +
g(x)$.  However, in base \proglang{R}, objects of class
\code{function} do not have arithmetic methods defined, so idiom such
as ``\code{f + g}'' returns an error, even though it has a perfectly
reasonable expectation.  The \pkg{vfunc} package offers this
functionality.  Other similar features are provided, which lead to
compact and readable idiom.  A wide class of coding bugs is
eliminated.
}

\Keywords{Functional programming, \proglang{R}}
\Plainkeywords{Functional programming, R}

%% publication information
%% NOTE: This needs to filled out ONLY IF THE PAPER WAS ACCEPTED.
%% If it was not (yet) accepted, leave them commented.
 \Volume{0}
 \Issue{0}
% \Month{MONTH}
 \Year{0000}
 \Submitdate{0000-00-00}
 \Acceptdate{0000-00-00}
 \Repository{https://github.com/RobinHankin/vfunc}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Robin K. S. Hankin\\
  University of Stirling\\
  Scotland\\
  E-mail: \email{hankin.robin@gmail.com}\\
  URL: \url{https://www.aut.ac.nz/profiles/robin-hankin}\\
}


%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\textbf{This document has not been peer-reviewed and is not an
  accepted \textsf{Tragula} publication.  It is intended as an example
  of the style and substance appropriate for submission to
  \textsf{Tragula}.}


\section{Introduction}

\setlength{\intextsep}{0pt}
\begin{wrapfigure}[3]{r}{0.2\textwidth}
  \begin{center}
    \includegraphics[width=1in]{vfunc.png}
  \end{center}
\end{wrapfigure}
Consider the following R session:
\begin{Schunk}
\begin{Sinput}
> f <- function(x){x^2}
> g <- function(x){1/(1-x)}
> f + g
\end{Sinput}
\begin{Soutput}
Error in f + g : non-numeric argument to binary operator
\end{Soutput}
\end{Schunk}

Above, there is a reasonably clear expectation for ``\code{f + g}'':
it should give a function that returns the sum of \code{f()} and
\code{g()}; something like \code{function(x)\{f(x) + g(x)\}}.
However, it returns an error because \code{f} and \code{g} are objects
of \proglang{S4} class \code{function}, which do not have an addition
method.  Further, it is not possible to define \code{Arith} group
\proglang{S4} methods [in this case, overloading addition,
``\code{+}''] so that this idiom operates as desired.  This is because
the \code{function} class is {\em sealed} in \code{S4}: the definition
of new methods for it is prohibited.  Here I present the \pkg{vfunc}
\proglang{R}~\citep{rcore2024_tragula} package that furnishes
appropriate idiom.  It is available on CRAN at
\url{https://CRAN.R-project.org/package=vfunc}.  The package defines a
new \proglang{S4} class \code{vf} (``virtual function'') which inherits
from \code{function}, but for which new methods can be defined.  This
device furnishes some ways to apply \code{Arith} methods for
functions.

\section{The package in use}

The package is designed so that objects of class \code{vf} operate as
functions but are subject to arithmetic operations, which are executed
transparently.  For example:


<<hidden_because_previous_chunk_was_not_executed, echo=FALSE>>=
f <- function(x){x^2}
g <- function(x){1/(1-x)}
@


<<vfuncfplusg>>=
library("vfunc")
f <- as.vf(f)
g <- as.vf(g)
(f + g)(1:10)
@

Above, we coerce \code{f} and \code{g} to objects of \proglang{S4}
class \code{vf} [for ``virtual function"].  Such objects have
\code{Arith} methods defined and may be combined arithmetically; for
example addition is dispatched to

<<asis=TRUE,echo=FALSE>>=
function(e1, e2){as.vf(function(...){e1(...) + e2(...)})}
@

The \code{vf} class has a single \code{.Data} slot of type
\code{function} which means that objects of this class inherit much of
the behaviour of base class \code{function}; above, we see that
\code{e1} and \code{e2} may be executed with their argument list
directly.  In practice this means that \code{f+g} behaves as intended,
and suggests other ways in which it can be used:

<<showfplusginvfunc>>=
(f + 4*g - f*g)(1:10)
@

The advantages of such idiom fall in to two main categories.  Firstly,
code can become considerably more compact; and secondly one can guard
against a wide class of hard-to-find bugs.  Now consider \code{f()} and
\code{g()} to be trivariate functions, each taking three arguments,
say,

<<>>=
f <- function(x,y,z){x + x*y - x/z}
g <- function(x,y,z){x^2 - z}
@

and $x=1.2$, $y=1.7$, $z=4.3$.  Given this, we wish to calculate

$$(f(x,y,z) + g(x,y,z))(f(x,y,z) + 4 - 2f(x,y,z)g(x,y,z)).$$

How would one code up such an expression in R?  The standard way would be

<<standardway>>=
 x <- 1.2
 y <- 1.7
 z <- 4.3		
(f(x,y,z) + g(x,y,z))*(f(x,y,z) + 4 - 2*f(x,y,z)*g(x,y,z))
@

Note the repeated specification of argument list \code{(x,y,z)}, repeated
here five times.  Now use the \pkg{vfunc} package:


<<usevfunc>>=
f <- as.vf(f)
g <- as.vf(g)
((f + g)*(f + 4 - 2*f*g))(x,y,z)
@

See how the package allows one to ``factorize'' the argument list so
it appears once, leading to more compact code.  It is also arguably
less error-prone, as the following example illustrates.  Consider

$$
f(x+z,y+z,f(x,x,y)-g(x,x,y)) + g(x+z, y+z,f(x,x,y)-g(x,x,y))
$$


(such expressions arise in the study of dynamical systems).  Note that
functions $f$ and $g$ are to be evaluated with two distinct sets of
arguments at different levels of nesting, namely $(x,x,y)$ at the
inner level and $(x+z,y+z,f(x,x,y)-g(x,x,y)$ at the outer.  Standard R
idiom would be


<<compexample>>=
f(x + z, y + z, f(x, x, y) - g(x, x, y)) + g(x + z, y + z, f(x, x, y) - g(x, x, y))
@

The author can attest that finding bugs in such expressions can be
difficult [it is easy to mistype \code{(x,x,y)} in one of its
occurences, yet difficult to detect the error].  However, \pkg{vfunc}
idiom would be

<<fgxzyz>>=
(f + g)(x + z, y + z, (f - g)(x, x, y))
@

which is certainly shorter, arguably neater and at least the author
finds such constructions considerably less error-prone.  In this form,
one can be sure that both \code{f()} and \code{g()} are called with
identical arguments at each of the two levels in the expression, as
the arguments appear only once.

\subsection{Overloading}

Looking again at the method for \code{vf} addition, viz

<<lookagain, asis=TRUE,echo=FALSE>>=
function(e1, e2){as.vf(function(...){e1(...) + e2(...)})}
@

we see the \code{+} operator is used to sum the return values of
\code{e1()} and \code{e2()}.  There is no reason that this operator
cannot itself be overloaded, and the \pkg{vfunc} package works
transparently if this is the case, with either \proglang{S3} or
\proglang{S4}.  Taking the \pkg{onion}
package~\citep{hankin2006_onion_tragula} as an example:

<<sprayexamp>>=
library("onion")
options("show_onions_compactly" = TRUE)
f <- as.vf(function(x,y){x + x*y})
g <- as.vf(function(x,y){x^2 + y})
(f + g - f*g)(1 + Hj,Hk)
@ 

\section{Primitive functions}

The R language includes a number of primitive functions as
\proglang{S4} Math generics, including the trig functions such as
\code{sin()}, and a few others such as the cumulative sum
\code{cumsum()}.  These functions are quite deep-seated and cannot
easily be modified to work with objects of class \code{vf}.  The
package defines capitalized versions of primitive functions to operate
with other objects of class \code{vf}.  Taking \code{sin()} as an
example we have

<<showsin>>=
vfunc::Sin
@

Then we may, for example, combine trig functions with user-defined functions:

<<combinetriganduser>>=
fun <- as.vf(function(x){x^2 + 2})
(fun(Sin) + Sin(fun) - 3*Sin*fun)(0.32)
@

Above, we see package idiom being used to evaluate $\sin^2(0.32) + 3 +
\sin(0.32^2+2) - 3\cdot\sin 0.32\cdot(0.32^2+2)$.  In base R:

<<seeeval>>=
fun(sin(0.32)) + sin(fun(0.32)) - 3*sin(0.32)*fun(0.32)
@

This construction allows one to define composite functions such as

<<defcomposite>>=
j <- as.vf(function(x,y){Cos(x) + Sin(x-y)})
k <- as.vf(function(x,y){Tan(x) + Log(x+y)})
l <- as.vf(function(x,y){Sin(x/2) + x^2   })
@

(note that functions \code{j()}, \code{k()} and \code{l()} are
bivariate).  Then compare

<<looktwo1>>=
(j + k + l)(Sin + Log, Cos + Exp)(Sin + Tan)(0.4)
@

with the one-stage idiom which reads:

<<echo=FALSE,print=FALSE>>=
j(sin(sin(0.4) + tan(0.4)) + log(sin(0.4) + tan(0.4)), cos(sin(0.4) + tan(0.4)) + exp(sin(0.4) + tan(0.4)))+
k(sin(sin(0.4) + tan(0.4)) + log(sin(0.4) + tan(0.4)), cos(sin(0.4) + tan(0.4)) + exp(sin(0.4) + tan(0.4)))+
l(sin(sin(0.4) + tan(0.4)) + log(sin(0.4) + tan(0.4)), cos(sin(0.4) + tan(0.4)) + exp(sin(0.4) + tan(0.4)))
@

<<looktwo2>>=
j(sin(sin(0.4) + tan(0.4)) + log(sin(0.4) + tan(0.4)), cos(sin(0.4) + tan(0.4)) +
exp(sin(0.4) + tan(0.4))) + k(sin(sin(0.4) + tan(0.4)) + log(sin(0.4) + tan(0.4)),
cos(sin(0.4) + tan(0.4)) + exp(sin(0.4) + tan(0.4)))+ l(sin(sin(0.4) + tan(0.4)) +
log(sin(0.4) + tan(0.4)), cos(sin(0.4) + tan(0.4)) + exp(sin(0.4) + tan(0.4)))
@

and the multi-stage idiom:

<<looktwo3>>=
A <- function(x,y){j(x,y) + k(x,y) + l(x,y)}
B <- function(x){sin(x) + log(x)}
C <- function(x){cos(x) + exp(x)}
D <- function(x){sin(x) + tan(x)}
x <- 0.4
A(B(D(x)), C(D(x)))
@ 

See how the one-stage idiom is very long, and the multi-stage idiom is
opaque [and nevertheless has repeated instances of \code{(x,y)} and
  \code{x}].

\section{Conclusions}

The \code{vfunc} package allows functions to be ``factorized'', that
is, \code{f(x) + g(x)} to be re-written \code{(f + g)(x)}.  This
allows for concise idiom and eliminates a certain class of coding
errors.  The package also allows for recursive application of such
ideas.  Further work might include an assessment of the package's
computational efficiency.

\bibliography{vfunc}

\end{document}

